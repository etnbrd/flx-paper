\section{Introduction}

\textit{``Release early, release often''}, \textit{``Fail fast''}.
The growth of a real-time web service is partially due to Internet's capacity to allow very quick releases of a minimal viable product (MVP).
% In a matter of hours, it is possible to release a prototype and start gathering a user community.
% \textit{``Release early, release often''}, and \textit{``Fail fast''} are the punchlines of the web entrepreneurial community.
It is crucial for the prosperity of such project to quickly validate that it meets the needs of its users.
Indeed, misidentifying the market needs is the first reason for startup failure\ftnt{https://www.cbinsights.com/blog/startup-failure-post-mortem/}.
Hence the development team quickly concretizes an MVP using a feature-driven approach and iterates on it.

% If the service successfully complies with users requirements, its community grows with its popularity.
The service needs to be scalable to be able to respond to the growth of its user-base.
However, feature-driven development best practices are hardly compatible with the required parallelism.
The features are organized in modules which disturb the organization of a parallel execution \cite{Clements2013a,Hughes1989,Parnas1972}.
Eventually the growth requires to discard the initial approach to adopt a more efficient processing model.
Many of the most efficient models decompose applications into execution units \cite{Fox1997, Welsh2000, Dean2008}.
% This decomposition may be spread over a cluster of commodity machines \cite{Fox1997}.
% MapReduce \cite{Dean2008} and the Staged Event-driven Architecture (SEDA) \cite{Welsh2000} are famous examples of that trend. %, using a pipeline architecture.
% Once split, the service parts are connected by an asynchronous messaging system.
% Many tools have been developed to express and manage these service parts and their communications.
% We can cite Spark \cite{Zaharia2012}, MillWheel \cite{Akidau2013}, Naiad \cite{McSherry}, Storm \cite{Toshniwal2014}, and many others.
However, these tools are in disruption from the initial approach.
% It requires the development team either to be trained or to hire experts, and more importantly, to start over the initial code base.
This shift causes the development team to spend development resources in background to start over the initial code base, without adding visible value for the users.
It is a risk for the evolution of the project.
Running out of cash and missing the right competences are the second and third reasons for startup failures$^2$.
% \ftnt{https://www.cbinsights.com/blog/startup-failure-post-mortem/}

The risk described above comes from a disruption between the two levels of application expression, the feature level and the execution level.
To avoid this risk and allow a continuous development process, we propose a tool to automatically map one level onto the other, and make the transition.
% , and allow an automatic transition from one to the other and back.
% we propose a tool to identify an alignment between the two levels, so as to allow a continuous transition from one to the other and back.
% This compiler transforms the initial code base into a high-level language.
% in the application allowing parallelism, hence scalability.
% This tool should allow a continuous development process.

We focus on web applications driven by users requests and developed in Javascript using the \textit{Node.js}\ftnt{https://nodejs.org/} execution environment.
% It is the most used language on Github\ftnt{http://githut.info/} and StackOverflow\ftnt{http://stackoverflow.com/tags}.
Javascript is widely adopted\ftnt{http://githut.info/}\ftnt{http://stackoverflow.com/tags} to develop web applications, and its event-loop model is very similar to a pipeline architecture.
% think that it is possible to identify the stages of this pipeline in an application. % a stream of requests passing through a pipeline
% Indeed, the event-loop used in \textit{Node.js} is very similar to a pipeline architecture.
% We 
So we propose a compiler to transform an application into a pipeline of parallel stages communicating by message streams.
We named these stages \textit{fluxions}, by contraction between a flux and a function.

% The contribution of this paper are the identification and partial resolution of the problems arising from the isolation of the global memory into fluxions.
% Second, a partial resolution of these problems, allowing an experimental compilation.
% We are interested in the problems arising from the isolation of the global memory into these fluxions.
%T his tool and its runtime aim not to modify the existing code, but rely on a high-level language expression over the initial code base.
% The contribution of this paper is the resolution of these problems, allowing the compilation.
We present a proof of concept for this compilation approach.
Section \ref{section:model} describes the execution environment targeted by this compiler.
Then, section \ref{section:compiler} presents the compiler, and section \ref{section:evaluation} its evaluation.
Section \ref{section:related} compare our work with related works.
And finally, we conclude this paper.