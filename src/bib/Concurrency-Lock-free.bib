Automatically generated by Mendeley Desktop 1.14.1-dev7
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@article{Herlihy1990,
author = {Herlihy, M.},
doi = {10.1145/99164.99185},
file = {:home/etn/Documents/PhD/Biblio/Herlihy - 1990 - A methodology for implementing highly concurrent data structures.pdf:pdf},
isbn = {0-89791-350-7},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {mar},
number = {3},
pages = {197--206},
publisher = {ACM},
title = {{A methodology for implementing highly concurrent data structures}},
url = {http://dl.acm.org/citation.cfm?id=99164.99185},
volume = {25},
year = {1990}
}
@incollection{Cong2005,
abstract = {Lock-free shared data structures in the setting of distributed computing have received a fair amount of attention. Major motivations of lock-free data structures include increasing fault tolerance of a (possibly heterogeneous) system and alleviating the problems associated with critical sections such as priority inversion and deadlock. For parallel computers with tightly-coupled processors and shared memory, these issues are no longer major concerns. While many of the results are applicable especially when the model used is shared memory multiprocessors, no prior studies have considered improving the performance of a parallel implementation by way of lock-free programming. As a matter of fact, often times in practice lock-free data structures in a distributed setting do not perform as well as those that use locks. As the data structures and algorithms for parallel computing are often drastically different from those in distributed computing, it is possible that lock-free programs perform better. In this paper we compare the similarity and difference of lock-free programming in both distributed and parallel computing environments and explore the possibility of adapting lock-free programming to parallel computing to improve performance. Lock-free programming also provides a new way of simulating PRAM and asynchronous PRAM algorithms on current parallel machines.},
author = {Cong, Guojing and Bader, David},
booktitle = {Lecture Notes in Computer Science, Volume 3296/2005},
doi = {10.1007/978-3-540-30474-6_54},
file = {:home/etn/Documents/PhD/Biblio/Cong, Bader - 2005 - Lock-Free Parallel Algorithms An Experimental Study.pdf:pdf},
pages = {1873--1875},
title = {{Lock-Free Parallel Algorithms: An Experimental Study}},
url = {http://www.cc.gatech.edu/$\sim$bader/papers/lockfree-HiPC2004.pdf http://www.springerlink.com/content/xw2v4a7h74j8ykhp/},
volume = {3296},
year = {2005}
}
@misc{Anderson1990,
author = {Anderson, James H. and Gouda, Mohamed G.},
file = {:home/etn/Documents/PhD/Biblio/Anderson, Gouda - 1990 - The virtue of Patience Concurrent Programming With And Without Waiting.pdf:pdf},
title = {{The virtue of Patience: Concurrent Programming With And Without Waiting}},
url = {http://www.cs.utexas.edu/ftp/techreports/tr90-23.pdf},
year = {1990}
}
@article{Herlihy1991,
author = {Herlihy, Maurice},
doi = {10.1145/114005.102808},
file = {:home/etn/Documents/PhD/Biblio/Herlihy - 1991 - Wait-free synchronization.pdf:pdf},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {linearization,wait-free synchronization},
month = {jan},
number = {1},
pages = {124--149},
publisher = {ACM},
title = {{Wait-free synchronization}},
url = {http://dl.acm.org/citation.cfm?id=114005.102808},
volume = {13},
year = {1991}
}
@article{Sundell2003,
abstract = {We present an efficient and practical lock-free implementation of a concurrent priority queue that is suitable for both fully concurrent (large multi-processor) systems as well as pre-emptive (multi-process) systems. Many algorithms for concurrent priority queues are based on mutual exclusion. However, mutual exclusion causes blocking which has several drawbacks and degrades the system's overall performance. Non-blocking algorithms avoid blocking, and are either lock-free or wait-free. Previously known non-blocking algorithms of priority queues did not perform well in practice because of their complexity, and they are often based on non-available atomic synchronization primitives. Our algorithm is based on the randomized sequential list structure called Skiplist, and a real-time extension of our algorithm is also described. In our performance evaluation we compare our algorithm with some of the most efficient implementations of priority queues known. The experimental results clearly show that our lock-free implementation outperforms the other lock-based implementations in all cases for 3 threads and more, both on fully concurrent as well as on pre-emptive systems.},
author = {Sundell, H. and Tsigas, P.},
doi = {10.1109/IPDPS.2003.1213189},
file = {:home/etn/Documents/PhD/Biblio/Sundell, Tsigas - 2003 - Fast and lock-free concurrent priority queues for multi-thread systems.pdf:pdf},
isbn = {0-7695-1926-1},
issn = {07437315},
journal = {Proceedings International Parallel and Distributed Processing Symposium},
number = {C},
pages = {11},
title = {{Fast and lock-free concurrent priority queues for multi-thread systems}},
url = {http://www.non-blocking.com/download/SunT03_PQueue_TR.pdf http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1213189},
volume = {00},
year = {2003}
}
@article{Niu2011,
abstract = {Stochastic Gradient Descent (SGD) is a popular algorithm that can achieve state-of-the-art performance on a variety of machine learning tasks. Several researchers have recently proposed schemes to parallelize SGD, but all require performance-destroying memory locking and synchronization. This work aims to show using novel theoretical analysis, algorithms, and implementation that SGD can be implemented without any locking. We present an update scheme called HOGWILD! which allows processors access to shared memory with the possibility of overwriting each other's work. We show that when the associated optimization problem is sparse, meaning most gradient updates only modify small parts of the decision variable, then HOGWILD! achieves a nearly optimal rate of convergence. We demonstrate experimentally that HOGWILD! outperforms alternative schemes that use locking by an order of magnitude.},
archivePrefix = {arXiv},
arxivId = {1106.5730},
author = {Niu, Feng and Recht, Benjamin and Re, Christopher and Wright, Stephen J.},
eprint = {1106.5730},
file = {:home/etn/Documents/PhD/Biblio/Niu et al. - 2011 - HOGWILD! A Lock-Free Approach to Parallelizing Stochastic Gradient Descent.pdf:pdf},
isbn = {9781618395993},
journal = {Advances in Neural Information Processing Systems},
number = {1},
pages = {21},
title = {{HOGWILD!: A Lock-Free Approach to Parallelizing Stochastic Gradient Descent}},
url = {http://i.stanford.edu/hazy/papers/hogwild-nips.pdf http://arxiv.org/abs/1106.5730},
year = {2011}
}
@inproceedings{Herlihy1988,
address = {New York, New York, USA},
author = {Herlihy, Maurice P.},
booktitle = {Proceedings of the seventh annual ACM Symposium on Principles of distributed computing - PODC '88},
doi = {10.1145/62546.62593},
file = {:home/etn/Documents/PhD/Biblio/Herlihy - 1988 - Impossibility and universality results for wait-free synchronization.pdf:pdf},
isbn = {0897912772},
month = {jan},
pages = {276--290},
publisher = {ACM Press},
title = {{Impossibility and universality results for wait-free synchronization}},
url = {http://dl.acm.org/citation.cfm?id=62546.62593},
year = {1988}
}
@article{Lamport1977,
author = {Lamport, Leslie},
doi = {10.1145/359863.359878},
file = {:home/etn/Documents/PhD/Biblio/Lamport - 1977 - Concurrent reading and writing.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {asynchronous multiprocessing,multiprocess synchronization,readers/writers problem,shared data},
month = {nov},
number = {11},
pages = {806--811},
publisher = {ACM},
title = {{Concurrent reading and writing}},
url = {http://dl.acm.org/citation.cfm?id=359863.359878},
volume = {20},
year = {1977}
}
