\section{Conclusion} \label{section:conclusion}

% In this paper, we presented our work to enable a \textit{Node.js} application to be dynamically and automatically scalable.
% The emerging design for an application to be scalable is to split it into parts to reduce coupling.
% From this insight, we designed an execution model for applications structured as a network of independent parts communicating by streams of messages.
% In a second part, we presented a compiler to transform a Javascript application into a network of independent parts.
% To identify these parts, we spotted rupture points as indicators for a possible parallelism and memory distribution.
% This compilation tool allow for the use of the distributed architecture previously described to enable scalability, with a minimum change on the imperative programming style mastered by most developers.

In this paper, we presented our work on a high-level language allowing to represent a web application as a network of independent parts communicating by message streams.
We presented a compiler to transform a \textit{Node.js} web application into this high-level representation.
To identify two independent parts, the compiler spots rupture points in the application, possibly leading to memory isolation and thus, parallelism.
We presented an example of a compiled application to show the limits of this approach.
This parallelism of this approach allows code-mobility which may lead to a better scalability.
We believe it can enable the scalability required by highly concurrent web applications without discarding the familiar programming models.

\endinput

Many frameworks for distributed systems focus mainly on the performances\cite{Akidau2013, Jain2006, Marz2011, Welsh2000, Wu2007, Zaharia2010}.
However, we focus on a compilation approach to replace the shift in programming model rather than the performance of the runtime.
We present in this section an extremely simplified but generic execution model inspired by the literature, only to support the confirmation of feasibility for the compilation process detailed in section \ref{section:compiler}.
The execution model is not distributed on remote machines, however it can isolate the execution of fluxions in different processes to reproduce the conditions of a distributed execution model.
We are interested in the problems arising from this isolation.

