\section{Conclusion} \label{section:conclusion}

% In this paper, we presented our work to enable a \textit{Node.js} application to be dynamically and automatically scalable.
% The emerging design for an application to be scalable is to split it into parts to reduce coupling.
% From this insight, we designed an execution model for applications structured as a network of independent parts communicating by streams of messages.
% In a second part, we presented a compiler to transform a Javascript application into a network of independent parts.
% To identify these parts, we spotted rupture points as indicators for a possible parallelism and memory distribution.
% This compilation tool allow for the use of the distributed architecture previously described to enable scalability, with a minimum change on the imperative programming style mastered by most developers.

In this paper, we presented our work on a high-level language allowing a high-level code reasoning.
We presented a compiler to transform a \textit{Node.js} web application into a network of independent parts communicating by message streams.
To identify these parts, the compiler spots rupture points in the application indicating a independence between two parts, possibly leading to parallelism and memory distribution.
We also presented the execution model to operate an application expressed in our high-level language.
This distributed approach allows code-mobility which may lead to a better scalability.
We believe this high-level approach can enable the scalability required by highly concurrent web applications without discarding the familiar monolithic and asynchronous programming model used in \textit{Node.js}.