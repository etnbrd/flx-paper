\section{Conclusion} \label{section:conclusion}

% In this paper, we presented our work to enable a \textit{Node.js} application to be dynamically and automatically scalable.
% The emerging design for an application to be scalable is to split it into parts to reduce coupling.
% From this insight, we designed an execution model for applications structured as a network of independent parts communicating by streams of messages.
% In a second part, we presented a compiler to transform a Javascript application into a network of independent parts.
% To identify these parts, we spotted rupture points as indicators for a possible parallelism and memory distribution.
% This compilation tool allow for the use of the distributed architecture previously described to enable scalability, with a minimum change on the imperative programming style mastered by most developers.

In this paper, we presented our work on a high-level language allowing to represent a web application as a network of independent parts communicating by message streams.
We presented a compiler to transform a \textit{Node.js} web application into this high-level representation.
To identify two independent parts, the compiler spots rupture points in the application, possibly leading to memory isolation and thus, parallelism.
The compiler is still in early development, and is unable to soundly distribute memory.
However, we proved it is possible to compile an application so that parts of its execution are parallelized, with minimum helps from the developer - only to identify the asynchronous calls.
We also presented the execution model to operate an application expressed in our high-level language.
This distributed approach allows code-mobility which may lead to a better scalability.
We believe this high-level approach can enable the scalability required by highly concurrent web applications without discarding the familiar monolithic and asynchronous programming model used in \textit{Node.js}.





